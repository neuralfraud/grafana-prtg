{"version":3,"sources":["../src/PRTGAPIService.js"],"names":["PRTGAPIService","alertSrv","backendSrv","PRTGAPI","api_url","username","passhash","cacheTimeoutMinutes","tzAutoAdjust","url","lastId","cache","tzAutoAdjustValue","performPRTGAPIRequest","then","jsClock","response","localTs","Date","now","Math","round","item","timestamp","hashValue","Promise","resolve","data","getCache","str","hash","length","idx","chr","charCodeAt","method","params","queryString","options","inCache","setCache","datasourceRequest","reject","message","groups","devices","sensors","channels","values","sensordata","messages","Version","histdata","treesize","error","status","statusText","groupFilter","deviceFilter","items","queryStr","invert","filterItems","match","_","trim","split","push","filter","findItem","group","device","sensor","name","utils","isRegex","rex","buildRegex","result","test","includes","performGroupSuggestQuery","filterQuery","hostFilter","performDeviceSuggestQuery","getGroups","filters","each","filteredGroups","join","sensorFilter","getHosts","hosts","host","performSensorSuggestQuery","getSensors","promises","map","objid","arrTmp","key","Object","keys","channel","sensor_raw","all","flatten","channelFilter","invertChannelFilter","getAllItems","target","filtermode","getItems","unixtime","dt","getFullYear","pad","getMonth","getDate","getHours","getMinutes","getSeconds","dateFrom","dateTo","hours","avg","getPRTGDate","history","iter","results","datetime","parse","substr","value","from","to","sensorId","events","time","datetime_raw","title","text","parent","type","angular","module","factory"],"mappings":"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","file":"PRTGAPIService.js","sourcesContent":["import angular from \"angular\";\r\nimport _ from \"lodash\";\r\nimport * as utils from \"./utils\";\r\n\r\n/**\r\n * PRTG API Service\r\n * Implements the high level functions that process data from PRTG\r\n */\r\n\r\n/** @ngInject */\r\nfunction PRTGAPIService(alertSrv, backendSrv) {\r\n  class PRTGAPI {\r\n    constructor(api_url, username, passhash, cacheTimeoutMinutes, tzAutoAdjust) {\r\n      this.url = api_url;\r\n      this.username = username;\r\n      this.passhash = passhash;\r\n      this.lastId = false;\r\n      this.cache = {};\r\n      this.cacheTimeoutMinutes = cacheTimeoutMinutes;\r\n      this.alertSrv = alertSrv;\r\n      this.backendSrv = backendSrv;\r\n      this.tzAutoAdjust = tzAutoAdjust;\r\n      this.tzAutoAdjustValue = 0;\r\n      if (tzAutoAdjust) {\r\n        this.performPRTGAPIRequest(\"status.json\").then(response => { \r\n          const jsClock =  response.jsClock; \r\n          const localTs = Date.now();\r\n          this.tzAutoAdjustValue = Math.round((localTs - jsClock),0) //i'll finish implementing this some day\r\n        })\r\n      }\r\n      \r\n    }\r\n\r\n    /**\r\n     * Tests whether a url has been stored in the cache.\r\n     * Returns boolean true | false\r\n     * \r\n     * Also actually implements deletion. TODO: Test Browser Cache API\r\n     * \r\n     * @param url \r\n     * @return boolean\r\n     */\r\n    inCache(url) {\r\n      for(var item in this.cache) {\r\n        if (Date.now() - this.cache[item].timestamp > (this.cacheTimeoutMinutes * 60000)) {\r\n          delete(this.cache[item])\r\n        }\r\n      }\r\n      \r\n      if (this.cache[this.hashValue(url)]) {\r\n        return true\r\n      }\r\n      return false;\r\n    }\r\n\r\n    /**\r\n     * retrieves a cached data result from the cache\r\n     *\r\n     * @param  url the URL of the request\r\n     * @return Promise\r\n     */\r\n    getCache(url) {\r\n      return Promise.resolve(this.cache[this.hashValue(url)].data);\r\n    }\r\n\r\n    /**\r\n     * stores a data result in the cache\r\n     *\r\n     * @param  url the URL of the request\r\n     * @param  data the response.data object of the request\r\n     * @return promise\r\n     */\r\n    setCache(url, data) {\r\n      this.cache[this.hashValue(url)] = {\"timestamp\": Date.now(), \"data\": data};\r\n      return this.getCache(url);\r\n    }\r\n\r\n    /**\r\n     * simple clone of a java hash value\r\n     * Kevin \"Pancake\" (http://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/)\r\n     *\r\n     * @param  e string to hash\r\n     * @return int32\r\n     */\r\n    hashValue(str) {\r\n      let hash = 0;\r\n      if (str.length === 0) return hash;\r\n      for (let idx = 0; idx < str.length; idx++) {\r\n        const chr = str.charCodeAt(idx);\r\n        hash = (hash << 5) - hash + chr;\r\n        hash = hash & hash; // Convert to 32bit integer\r\n      }\r\n      return hash;\r\n    }\r\n\r\n    /**\r\n     * Request data from PRTG API\r\n     *\r\n     * @param  method the API method (e.g., table.json)\r\n     * @param  params HTTP query string query parameters\r\n     * @return promise\r\n     */\r\n    performPRTGAPIRequest(method, params) {\r\n      const queryString =\r\n        \"username=\" +\r\n        this.username +\r\n        \"&passhash=\" +\r\n        this.passhash +\r\n        \"&\" +\r\n        params;\r\n      const options = {\r\n        method: \"GET\",\r\n        url: this.url + \"/\" + method + \"?\" + queryString\r\n      };\r\n\r\n      if (this.inCache(options.url)) {\r\n        return this.getCache(options.url);\r\n      } else {\r\n        return this.setCache(\r\n          options.url,\r\n          this.backendSrv.datasourceRequest(options).then(\r\n            response => {\r\n              if (!response.data) {\r\n                return Promise.reject({\r\n                  message: \"Response contained no data\"\r\n                });\r\n              }\r\n\r\n              if (response.data.groups) {\r\n                return response.data.groups;\r\n              } else if (response.data.devices) {\r\n                return response.data.devices;\r\n              } else if (response.data.sensors) {\r\n                return response.data.sensors;\r\n              } else if (response.data.channels) {\r\n                return response.data.channels;\r\n              } else if (response.data.values) {\r\n                return response.data.values;\r\n              } else if (response.data.sensordata) {\r\n                return response.data.sensordata;\r\n              } else if (response.data.messages) {\r\n                return response.data.messages;\r\n              } else if (response.data.Version) {\r\n                return response.data;\r\n              } else if (response.data.histdata) {\r\n                if (response.data.treesize == 0) {\r\n                  return Promise.reject({\r\n                    message: \"No objects returned by query (treesize = 0). Try expanding your time range or something.\\n\\n: Request:\\n\" + params\r\n                  })\r\n                }\r\n                return response.data.histdata;\r\n              } else {\r\n                return Promise.reject({\r\n                    message:\r\n                      \"Not sure how to handle this request.\\n\\nRequest:\\n\" +\r\n                      params +\r\n                      \"\\n\"\r\n                  });\r\n              }\r\n            },\r\n            error => {\r\n              return Promise.reject({\r\n                message: error.status + \": \" + error.statusText\r\n              });\r\n            }\r\n          )\r\n        );\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Only used in connection testing\r\n     * \r\n     * @return Promise\r\n     */\r\n    getVersion() {\r\n      return this.performPRTGAPIRequest(\"status.json\").then(function(response) {\r\n        if (!response) {\r\n          return \"ERROR. No response.\";\r\n        } else {\r\n          return response.Version;\r\n        }\r\n      });\r\n    }\r\n\r\n    /**\r\n     * Query API for list of groups\r\n     *\r\n     * @return Promise - JSON result set\r\n     */\r\n    performGroupSuggestQuery() {\r\n      const params =\r\n        \"content=groups&count=9999&columns=objid,group,probe,tags,active,status,message,priority\";\r\n      return this.performPRTGAPIRequest(\"table.json\", params);\r\n    }\r\n\r\n    /**\r\n     * Query API for list of devices\r\n     * @param {string} groupFilter - raw string, comma separated strings, or regular expression pattern\r\n     * @return Promise - JSON result set\r\n     */\r\n    performDeviceSuggestQuery(groupFilter) {\r\n      let params =\r\n        \"content=devices&count=9999&columns=objid,device,group,probe,tags,active,status,message,priority\";\r\n      if (groupFilter) {\r\n        params += \",group\" + groupFilter;\r\n      }\r\n      return this.performPRTGAPIRequest(\"table.json\", params);\r\n    }\r\n\r\n    /**\r\n     * Query API for list of sensors bound to a given device\r\n     * @param {string} deviceFilter - raw string, comma separated strings, or regular expression pattern\r\n     * @return promise - JSON result set\r\n     */\r\n    performSensorSuggestQuery(deviceFilter) {\r\n      let params =\r\n        \"content=sensors&count=9999&columns=objid,sensor,device,group,probe,tags,active,status,message,priority\";\r\n      if (deviceFilter) {\r\n        params += deviceFilter;\r\n      }\r\n        \r\n      return this.performPRTGAPIRequest(\"table.json\", params);\r\n    }\r\n\r\n    /**\r\n     * Filter a PRTG collection against a filter string \r\n     * \r\n     * @param {collection} items - PRTG Data object \r\n     * @param {string} queryStr - Query filter, raw string, comma separated strings, or regular expression pattern\r\n     * @param {boolean} invert - when set to boolean true, negates the return value. \r\n     * @return {boolean} result of text expression\r\n     */\r\n    filterQuery(items, queryStr, invert = false) {\r\n      /**\r\n       * group device sensor includes properties:\r\n       * objid: num\r\n       * sensor: Name\r\n       * device: Device name\r\n       * group: Group name\r\n       * tags: comma separated\r\n       * active: true|false\r\n       * active_raw: -1 for true? wtf\r\n       * status: Status text\r\n       * status_raw: number\r\n       * message: html message\r\n       * message_raw: text message\r\n       * priority: number 1-5\r\n       */\r\n      let filterItems = [];\r\n      if (queryStr.match(/{[^{}]+}/g)) {\r\n        filterItems = _.trim(queryStr, \"{}\").split(\",\");\r\n      } else {\r\n        filterItems.push(queryStr);\r\n      }\r\n      return _.filter(items, item => {\r\n        let findItem;\r\n        if (item.group && !item.device) {\r\n          findItem = item.group;\r\n        } else if (item.device && !item.sensor) {\r\n          findItem = item.device;\r\n        } else if (item.sensor && !item.name) {\r\n          findItem = item.sensor;\r\n        } else if (item.name) {\r\n          findItem = item.name;\r\n        } else {\r\n          return false;\r\n        }\r\n        if (utils.isRegex(queryStr)) {\r\n          const rex = utils.buildRegex(queryStr);\r\n          const result = rex.test(findItem);\r\n          if (invert) {\r\n            return !result;\r\n          }\r\n          return result;\r\n        }\r\n        if (filterItems.length === 0) {\r\n          return true;\r\n        }\r\n        if (invert) {\r\n          return !filterItems.includes(findItem);\r\n        }\r\n        return filterItems.includes(findItem);\r\n      });\r\n    }\r\n\r\n    /**\r\n     * Retrive groups and filter with an optional filter string\r\n     * \r\n     * @param {string} groupFilter - raw string, comma separated strings, or regular expression pattern\r\n     * @return {collection} - filtered PRTG data object\r\n     */\r\n    getGroups(groupFilter = \"/.*/\") {\r\n      return this.performGroupSuggestQuery().then(groups => {\r\n        return this.filterQuery(groups, groupFilter);\r\n      });\r\n    }\r\n\r\n    /**\r\n     * Retrieve hosts and filter with an optional filter string.\r\n     * \r\n     * @param {*} groupFilter - raw string, comma separated strings, or regular expression pattern\r\n     * @param {*} hostFilter - raw string, comma separated strings, or regular expression pattern\r\n     * @return {collection} - filtered PRTG data object\r\n     */\r\n    getHosts(groupFilter = \"/.*/\", hostFilter = \"/.*/\") {\r\n      //this is kind of silly but no need to include filter_group params if you include all...\r\n      if (groupFilter == \"/.*/\") {\r\n        return this.performDeviceSuggestQuery().then(devices => {\r\n          return this.filterQuery(devices, hostFilter);\r\n        });\r\n      } else {\r\n        return this.getGroups(groupFilter).then(filteredGroups => {\r\n          const filters = [];\r\n          _.each(filteredGroups, group => {\r\n            filters.push(\"filter_group=\" + group.group);\r\n          });\r\n\r\n          return this.performDeviceSuggestQuery(\r\n            \"&\" + filters.join(\"&\")\r\n          ).then(devices => {\r\n            return this.filterQuery(devices, hostFilter);\r\n          });\r\n        });\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Retrieve sensors and filter with an optional filter string.\r\n     * \r\n     * @param {string} groupFilter - raw string, comma separated strings, or regular expression pattern\r\n     * @param {string} hostFilter - raw string, comma separated strings, or regular expression pattern\r\n     * @param {string} sensorFilter - raw string, comma separated strings, or regular expression pattern\r\n     * @return {collection} - filtered PRTG data object\r\n     */\r\n    getSensors(\r\n      groupFilter = \"/.*/\",\r\n      hostFilter = \"/.*/\",\r\n      sensorFilter = \"/.*/\"\r\n    ) {\r\n      return this.getHosts(groupFilter, hostFilter).then(hosts => {\r\n        const filters = [];\r\n        _.each(hosts, host => {\r\n          filters.push(\"filter_device=\" + host.device);\r\n        });\r\n        if (hostFilter == \"/.*/\" && groupFilter == \"/.*/\") {\r\n          return this.performSensorSuggestQuery().then(sensors => {\r\n            return this.filterQuery(sensors, sensorFilter);\r\n          });\r\n        } else {\r\n          return this.performSensorSuggestQuery(\r\n            \"&\" + filters.join(\"&\")\r\n          ).then(sensors => {\r\n            return this.filterQuery(sensors, sensorFilter);\r\n          });\r\n        }\r\n      });\r\n    }\r\n\r\n    /**\r\n     * Retrieve full data object with channel definitions using an optional filter string\r\n     * \r\n     * @param {*} groupFilter - raw string, comma separated strings, or regular expression pattern \r\n     * @param {*} hostFilter - raw string, comma separated strings, or regular expression pattern \r\n     * @param {*} sensorFilter - raw string, comma separated strings, or regular expression pattern \r\n     * @return {collection} - PRTG data object with channel and sensor properties\r\n     */\r\n    getAllItems(\r\n      groupFilter = \"/.*/\",\r\n      hostFilter = \"/.*/\",\r\n      sensorFilter = \"/.*/\"\r\n    ) {\r\n      return this.getSensors(\r\n        groupFilter,\r\n        hostFilter,\r\n        sensorFilter\r\n      ).then(sensors => {\r\n        /**\r\n         * For each sensor, retrieve one count of \"values\" from table.json - this will include all of the actual\r\n         * channel names, which are then used to retrieve the data. \r\n         */\r\n        const promises = _.map(sensors, sensor => {\r\n          const params = \"content=values&output=json&columns=value_&noraw=1&count=1&usecaption=true&id=\"+ sensor.objid \r\n          //const params = \"content=channels&columns=sensor,name&id=\" + sensor.objid;\r\n          return this.performPRTGAPIRequest(\r\n            \"table.json\",\r\n            params\r\n          ).then(channels => {\r\n           let arrTmp = []\r\n            for (var key in Object.keys(channels[0])) {\r\n              let channel = {}\r\n              channel.sensor = sensor.objid;\r\n              channel.sensor_raw = sensor.sensor;\r\n              channel.device = sensor.device;\r\n              channel.group = sensor.group;\r\n              channel.name = Object.keys(channels[0])[key];\r\n              channel.channel = channel.name\r\n              arrTmp.push(channel)\r\n            }\r\n            return Promise.all(arrTmp)\r\n          });\r\n        });\r\n        return Promise.all(promises).then(_.flatten);\r\n      });\r\n    }\r\n\r\n    /**\r\n     * Retrieve full data object with channel definitions using an optional filter string.\r\n     * The results are then filtered against a channelFilter expression.\r\n     * \r\n     * @param {string} groupFilter - raw string, comma separated strings, or regular expression patter \r\n     * @param {string} deviceFilter - raw string, comma separated strings, or regular expression patter \r\n     * @param {string} sensorFilter - raw string, comma separated strings, or regular expression pattern\r\n     * @param {string} channelFilter - raw string, comma separated strings, or regular expression pattern\r\n     * @param {boolean} invertChannelFilter - if set to boolean true, negates the result of the channelFilter expression\r\n     */\r\n    getItems(\r\n      groupFilter,\r\n      deviceFilter,\r\n      sensorFilter,\r\n      channelFilter,\r\n      invertChannelFilter = false\r\n    ) {\r\n      return this.getAllItems(\r\n        groupFilter,\r\n        deviceFilter,\r\n        sensorFilter\r\n      ).then(items => {\r\n        return this.filterQuery(items, channelFilter, invertChannelFilter);\r\n      });\r\n    }\r\n\r\n    /**\r\n     * This fires off a series of API queries that ends up either confirming or expanding the targets\r\n     * originally selected in the dashboard. For instance, if I use /Processor/ as the channel name in a query, \r\n     * that actually means \"all channels containing 'Processor', so it means we have to fetch a real list of \r\n     * things from the API and then create necessary target objects before the data can be fetched. \r\n     * \r\n     * TODO: Carry out all of this garbage prior to saving the dashboard, it'll make things faster. \r\n     * @param {*} target \r\n     */\r\n    getItemsFromTarget(target) {\r\n      let filtermode = (target.options.invertChannelFilter) ? true : false\r\n      return this.getItems(\r\n        target.group.name,\r\n        target.device.name,\r\n        target.sensor.name,\r\n        target.channel.name,\r\n        filtermode\r\n      );\r\n    }\r\n\r\n    /**\r\n     * convert a UNIX timestamp into a PRTG date string for queries\r\n     * YYYY-MM-DD-HH-MM-SS\r\n     * \r\n     * @param unixtime UNIX format timestamp\r\n     */\r\n    getPRTGDate(unixtime) {\r\n      const dt = new Date(unixtime * 1000);\r\n      const str = [\r\n        dt.getFullYear(),\r\n        utils.pad(dt.getMonth(), true),\r\n        utils.pad(dt.getDate()),\r\n        utils.pad(dt.getHours()),\r\n        utils.pad(dt.getMinutes()),\r\n        utils.pad(dt.getSeconds())\r\n      ];\r\n      return str.join(\"-\");\r\n    }    \r\n\r\n    /**\r\n     * Retrieve history data from a single sensor.\r\n     * @param {number} sensor - sensor ID\r\n     * @param {string} channel - channel name\r\n     * @param {number} dateFrom - timestamp of start time\r\n     * @param {number} dateTo - timestamp of end time\r\n     */\r\n    getItemHistory(sensor, channel, dateFrom, dateTo) {\r\n      const hours = (dateTo - dateFrom) / 3600;\r\n      let avg = 0;\r\n      if (hours > 12 && hours < 36) {\r\n        avg = \"300\";\r\n      } else if (hours > 36 && hours < 745) {\r\n        avg = \"3600\";\r\n      } else if (hours > 745) {\r\n        avg = \"86400\";\r\n      }\r\n\r\n      const method = \"historicdata.json\";\r\n      const params =\r\n        \"id=\" +\r\n        sensor +\r\n        \"&sdate=\" +\r\n        this.getPRTGDate(dateFrom) +\r\n        \"&edate=\" +\r\n        this.getPRTGDate(dateTo) +\r\n        \"&avg=\" +\r\n        avg +\r\n        \"&pctshow=false&pctmode=false&usecaption=1\";\r\n      /*\r\n             * Modified to read the \"statusid\" value, this can then be mapped via lookup table to a PRTG status type\r\n             * 1=Unknown, 2=Scanning, 3=Up, 4=Warning, 5=Down, 6=No Probe, 7=Paused by User, 8=Paused by Dependency,\r\n             * 9=Paused by Schedule, 10=Unusual, 11=Not Licensed, 12=Paused Until, 13=Down Acknowledged, 14=Down Partial\r\n             */\r\n      const history = [];\r\n      \r\n      return this.performPRTGAPIRequest(method, params).then(results => {\r\n        for (let iter = 0; iter < results.length; iter++)\r\n        {\r\n          history.push({\r\n            sensor: sensor,\r\n            channel: channel,\r\n            datetime: Date.parse(results[iter][\"datetime\"].substr(0,22)), //moar haxx\r\n            value: results[iter][channel] \r\n          });\r\n        }\r\n        return history;\r\n      });\r\n    }\r\n\r\n    /**\r\n     * Retrieve messages for a given sensor. Used only for annotation queries.\r\n     * \r\n     * @param {number} from - Earliest time in range\r\n     * @param {number} to - Latest time in range\r\n     * @param {number} sensorId - Numeric ID of Sensor \r\n     */\r\n    getMessages(from, to, sensorId) {\r\n      const method = \"table.json\";\r\n      const params =\r\n        \"&content=messages&columns=objid,datetime,parent,type,name,status,message&id=\" +\r\n        sensorId;\r\n      return this.performPRTGAPIRequest(method, params).then(function(\r\n        messages\r\n      ) {\r\n        const events = [];\r\n        let time = 0;\r\n        _.each(messages, function(message) {\r\n          time = Math.round((message.datetime_raw - 25569) * 86400, 0);\r\n          if (time > from && time < to) {\r\n            events.push({\r\n              time: time * 1000,\r\n              title: message.status,\r\n              text:\r\n                \"<p>\" +\r\n                message.parent +\r\n                \"(\" +\r\n                message.type +\r\n                \") Message:<br>\" +\r\n                message.message +\r\n                \"</p>\"\r\n            });\r\n          }\r\n        });\r\n        return events;\r\n      });\r\n    }\r\n  }\r\n  return PRTGAPI;\r\n}\r\n\r\n//register a new module\r\nangular.module(\"grafana.services\").factory(\"PRTGAPIService\", PRTGAPIService);\r\n"]}