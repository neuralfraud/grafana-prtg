{"version":3,"sources":["../src/xmlparser.js"],"names":["XMLXform","method","xmlString","xml","undefined","xslt","xslt2","json","newxml","window","DOMParser","parser","parseFromString","xsltProcessor","XSLTProcessor","importStylesheet","transformToDocument","xsltProcessor2","transformToFragment","document","textContent","JSON","parse"],"mappings":";;;;;;;;;;;;;;;;gCAoBaA,Q,GACT,kBAAYC,MAAZ,EAAoBC,SAApB,EAA+B;AAAA;;AAE3B,qBAAKC,GAAL,GAAWC,SAAX;AACA,qBAAKC,IAAL;;AAqCA,qBAAKC,KAAL;;AAwEA,oBAAIC,IAAJ,EAASC,MAAT;AACA,oBAAIC,OAAOC,SAAX,EAAsB;AAClB,wBAAIC,SAAS,IAAID,SAAJ,EAAb;AACA,yBAAKP,GAAL,GAAWQ,OAAOC,eAAP,CAAuBV,SAAvB,EAAkC,iBAAlC,CAAX;AACA,yBAAKG,IAAL,GAAYM,OAAOC,eAAP,CAAuB,KAAKP,IAA5B,EAAkC,iBAAlC,CAAZ;AACA,yBAAKC,KAAL,GAAaK,OAAOC,eAAP,CAAuB,KAAKN,KAA5B,EAAmC,iBAAnC,CAAb;AACH;AACD,oBAAIO,gBAAgB,IAAIC,aAAJ,EAApB;AACID,8BAAcE,gBAAd,CAA+B,KAAKV,IAApC;AACAG,yBAASK,cAAcG,mBAAd,CAAkC,KAAKb,GAAvC,CAAT;AACJ;AACA,oBAAIc,iBAAiB,IAAIH,aAAJ,EAArB;AACIG,+BAAeF,gBAAf,CAAgC,KAAKT,KAArC;AACAC,uBAAOU,eAAeC,mBAAf,CAAmCV,MAAnC,EAA2CW,QAA3C,EAAqDC,WAA5D;AACJ,uBAAOC,KAAKC,KAAL,CAAWf,IAAX,CAAP;AACH,a","file":"xmlparser.js","sourcesContent":["/**\n * Grafana Datasource Plugin for PRTG API Interface\n * XML Transformation and Conversion to JSON\n * \n * 20151206 03:10 Jason Lashua\n * Proof of Concept. Based on publicly available plugins.\n *\n * PRTG sends data by channel, both formatted and raw, so like:\n * value 100%, channel 1\n * value_raw 100%, channel 1\n * value 3 gb/s, channel 2\n * value_raw 30492059, channel 2\n *\n * the nodes being unrelated results in repeat objects.\n *\n * first xsl sorts nodes by name, such that all <value> elements are\n * together, and all <value_raw> elements are together.\n * This results in arrays being created, which we can use.\n *\n */\nexport class XMLXform {\n    constructor(method, xmlString) {\n    \n        this.xml = undefined;\n        this.xslt = `<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n    <!--<xsl:output method=\"text\" encoding=\"utf-8\"/>-->\n\n<xsl:key name=\"kvalue\" match=\"value\" use=\"@channelid\" />\n<xsl:key name=\"kvalue_raw\" match=\"value_raw\" use=\"@channelid\" />\n\n\n <xsl:template match=\"histdata\">\n    <xsl:copy>\n        <xsl:apply-templates select=\"item\"/>\n    </xsl:copy>\n</xsl:template>\n\n<xsl:template match=\"item\">\n    <xsl:copy>\n        <xsl:apply-templates select=\"datetime\" />\n        <xsl:apply-templates select=\"datetime_raw\" />\n        <xsl:apply-templates select=\"value\">\n            <xsl:sort select=\"@channelid\" data-type=\"number\" order=\"ascending\" />\n        </xsl:apply-templates>\n        <xsl:apply-templates select=\"value_raw\">\n            <xsl:sort select=\"@channelid\" data-type=\"number\" order=\"ascending\" />\n        </xsl:apply-templates>\n    </xsl:copy>\n</xsl:template>\n<xsl:template match=\"item\">\n    <xsl:copy>\n        <xsl:copy-of select=\"datetime\" />\n        <xsl:copy-of select=\"datetime_raw\" />\n        <xsl:copy-of select=\"value\" />\n        <xsl:copy-of select=\"value_raw\" />\n    </xsl:copy>\n</xsl:template>\n</xsl:stylesheet>\n`;\n\n        this.xslt2 = `<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n    <xsl:output method=\"text\" encoding=\"utf-8\"/>\n \n    <xsl:template match=\"/*[node()]\">\n        <xsl:text>{</xsl:text>\n        <xsl:apply-templates select=\".\" mode=\"detect\" />\n        <xsl:text>}</xsl:text>\n    </xsl:template>\n \n    <xsl:template match=\"*\" mode=\"detect\">\n        <xsl:choose>\n            <xsl:when test=\"name(preceding-sibling::*[1]) = name(current()) and name(following-sibling::*[1]) != name(current())\">\n                    <xsl:apply-templates select=\".\" mode=\"obj-content\" />\n                <xsl:text>]</xsl:text>\n                <xsl:if test=\"count(following-sibling::*[name() != name(current())]) &gt; 0\">, </xsl:if>\n            </xsl:when>\n            <xsl:when test=\"name(preceding-sibling::*[1]) = name(current())\">\n                    <xsl:apply-templates select=\".\" mode=\"obj-content\" />\n                    <xsl:if test=\"name(following-sibling::*) = name(current())\">, </xsl:if>\n            </xsl:when>\n            <xsl:when test=\"following-sibling::*[1][name() = name(current())]\">\n                <xsl:text>\"</xsl:text><xsl:value-of select=\"name()\"/><xsl:text>\" : [</xsl:text>\n                    <xsl:apply-templates select=\".\" mode=\"obj-content\" /><xsl:text>, </xsl:text>\n            </xsl:when>\n            <xsl:when test=\"count(./child::*) > 0 or count(@*) > 0\">\n                <xsl:text>\"</xsl:text><xsl:value-of select=\"name()\"/>\" : <xsl:apply-templates select=\".\" mode=\"obj-content\" />\n                <xsl:if test=\"count(following-sibling::*) &gt; 0\">, </xsl:if>\n            </xsl:when>\n            <xsl:when test=\"count(./child::*) = 0\">\n                <xsl:text>\"</xsl:text><xsl:value-of select=\"name()\"/>\" : \"<xsl:apply-templates select=\".\"/><xsl:text>\"</xsl:text>\n                <xsl:if test=\"count(following-sibling::*) &gt; 0\">, </xsl:if>\n            </xsl:when>\n        </xsl:choose>\n    </xsl:template>\n \n    <xsl:template match=\"*\" mode=\"obj-content\">\n        <xsl:text>{</xsl:text>\n            <xsl:apply-templates select=\"@*\" mode=\"attr\" />\n            <xsl:if test=\"count(@*) &gt; 0 and (count(child::*) &gt; 0 or text())\">, </xsl:if>\n            <xsl:apply-templates select=\"./*\" mode=\"detect\" />\n            <xsl:if test=\"count(child::*) = 0 and text() and not(@*)\">\n                <xsl:text>\"</xsl:text><xsl:value-of select=\"name()\"/>\" : \"<xsl:value-of select=\"text()\"/><xsl:text>\"</xsl:text>\n            </xsl:if>\n            <xsl:if test=\"count(child::*) = 0 and text() and @*\">\n                <xsl:text>\"text\" : \"</xsl:text><xsl:value-of select=\"text()\"/><xsl:text>\"</xsl:text>\n            </xsl:if>\n        <xsl:text>}</xsl:text>\n        <xsl:if test=\"position() &lt; last()\">, </xsl:if>\n    </xsl:template>\n \n    <xsl:template match=\"@*\" mode=\"attr\">\n        <xsl:text>\"</xsl:text><xsl:value-of select=\"name()\"/>\" : \"<xsl:value-of select=\".\"/><xsl:text>\"</xsl:text>\n        <xsl:if test=\"position() &lt; last()\">,</xsl:if>\n    </xsl:template>\n \n    <xsl:template match=\"node/@TEXT | text()\" name=\"removeBreaks\">\n        <xsl:param name=\"pText\" select=\"normalize-space(.)\"/>\n        <xsl:choose>\n            <xsl:when test=\"not(contains($pText, '&#xA;'))\"><xsl:copy-of select=\"$pText\"/></xsl:when>\n            <xsl:otherwise>\n                <xsl:value-of select=\"concat(substring-before($pText, '&#xD;&#xA;'), ' ')\"/>\n                <xsl:call-template name=\"removeBreaks\">\n                    <xsl:with-param name=\"pText\" select=\"substring-after($pText, '&#xD;&#xA;')\"/>\n                </xsl:call-template>\n            </xsl:otherwise>\n        </xsl:choose>\n    </xsl:template>\n \n</xsl:stylesheet>\n`;\n\n        var json,newxml;\n        if (window.DOMParser) {\n            var parser = new DOMParser();  \n            this.xml = parser.parseFromString(xmlString, \"application/xml\");\n            this.xslt = parser.parseFromString(this.xslt, \"application/xml\");\n            this.xslt2 = parser.parseFromString(this.xslt2, \"application/xml\");\n        }\n        var xsltProcessor = new XSLTProcessor();\n            xsltProcessor.importStylesheet(this.xslt);\n            newxml = xsltProcessor.transformToDocument(this.xml);\n        // Using a separate XSLTProcessor instance resolves issue with Firefox.\n        var xsltProcessor2 = new XSLTProcessor();\n            xsltProcessor2.importStylesheet(this.xslt2);\n            json = xsltProcessor2.transformToFragment(newxml, document).textContent;\n        return JSON.parse(json);\n    }\n}\n\n"]}